//#include "defs.h"
//#include "interrupt.h"
//#include "audio.h"
//
//int main()
//{
////	IntcInitialize();
////	AudioInitialize();
////	PlayMusic("land_s.wav");
//}

#include "xaudioformatter.h"
#include "xparameters.h"
#include "xil_exception.h"
#include "xscugic.h"
#include "stdio.h"
#include "xi2stx.h"
#include "xiicps.h"
#include "adau1761.h"
#include "xil_cache.h"
#include "fs.h"

#define ADMA_DEV_ID XPAR_XAUDIOFORMATTER_0_DEVICE_ID
#define I2S_TX_DEV_ID XPAR_XI2STX_0_DEVICE_ID
#define IIC_DEV_ID XPAR_XIICPS_0_DEVICE_ID
#define INTC_DEV_ID XPAR_SCUGIC_SINGLE_DEVICE_ID
#define TX_INTR_ID XPAR_FABRIC_AUDIO_FORMATTER_0_VEC_ID
#define INTC_DEVICE_ID XPAR_SCUGIC_SINGLE_DEVICE_ID
#define DDR_BASE_ADDR XPAR_PS7_DDR_0_S_AXI_BASEADDR
#define MEM_BASE_ADDR (DDR_BASE_ADDR + 0X1000000)
#define TX_BUFFER_BASE (MEM_BASE_ADDR + 0x00000000)

#define FS 48
#define MCLK 384*48 //384*48
#define IIC_SCLK_RATE 100000

#define IIC_AUDIO_ADDR (0x76>>1)

#define PERIOD 8
#define PERIOD_BYTES 64

XAudioFormatter adma;
XScuGic intc;
XI2s_Tx i2s_tx;
XIicPs iic;

XAudioFormatterHwParams hw_params = {TX_BUFFER_BASE,2,BIT_DEPTH_24,PERIOD,PERIOD_BYTES};


void init_system();
void write_reg(u8 reg_addr, u8 reg_data);
void init_audio();

int is_done;
int intr_times = 0;
u32 music_len;
u64 music_buf_addr;


//int debug_b = 0;
//u64 music_buf_addr_debug;
//u64 music_buf_addr_debug_2;


int main(void)
{
	printf("start!\n");
	init_system();
	init_audio();
	init_fs();
	printf("init finish! \n");

	music_buf_addr = TX_BUFFER_BASE;

	u8 * tx_buffer_ptr = (u8 *) TX_BUFFER_BASE;
	is_done = 0;
	//read_wav("wave.wav",TX_BUFFER_BASE,len);

	UINT count;
	FIL file;


//	//for debug
//	music_buf_addr_debug = music_buf_addr+PERIOD*PERIOD_BYTES;
//	music_buf_addr_debug_2 = music_buf_addr;
//	int p = 0;
//	for(int i = 0;i<PERIOD*2;i++)
//	{
//		tx_buffer_ptr[p] = 0xFF;
//		tx_buffer_ptr[p+1] = 0xFF;
//		tx_buffer_ptr[p+2] = 0xFF;
//		tx_buffer_ptr[p+3] = 0xFF;
//		tx_buffer_ptr[p+4] = 0xFF;
//		tx_buffer_ptr[p+5] = 0xFF;
//		tx_buffer_ptr[p+6] = 0xFF;
//		tx_buffer_ptr[p+7] = 0xFF;
//		p += 8;
//	}




///////////////////////////////////////////////////////////////////
	f_open(&file,"land_s.wav",FA_READ);
	f_lseek(&file,0x110-4); //wave:0x62 + 4 land:0x110 star: 0xc2+4
	f_read(&file,tx_buffer_ptr,4,&count);
	Xil_DCacheFlush();
	u32 len_f = *((u32*)tx_buffer_ptr);
	//music_len = len_f;
	printf("length: %d\n",(int)len_f);

	//copy the data to DDR in the 32 bit format
	u32 file_len = 0;
	u8* buf_addr = tx_buffer_ptr;
	//u8 temp_byte[3];
	int temp_i = 0;
	u8 temp_buf;
	while(file_len<=len_f)
	{
		f_read(&file,&buf_addr[temp_i],3,&count);
		if(count<3) break;
		buf_addr[temp_i+3] = 0;
		temp_buf = buf_addr[temp_i+1] & 0x03;
		buf_addr[temp_i+2] = (buf_addr[temp_i+2]>>2)|(temp_buf<<6);
		temp_buf = buf_addr[temp_i] & 0x03;
		buf_addr[temp_i+1] = (buf_addr[temp_i+1]>>2)|(temp_buf<<6);
		buf_addr[temp_i] = buf_addr[temp_i]>>2;
		music_len += 4;
		file_len += 3;
		temp_i += 4;
	}



/////////////////////////////////////////////////////
	Xil_DCacheFlush();



	printf("start transfer\n");
	XAudioFormatterDMAStart(&adma);
	while(1);
}

static void tx_intr_handler(void* callback)
{
	intr_times += 1;
	XAudioFormatter* afi = (XAudioFormatter*)callback;
	afi->ChannelId = XAudioFormatter_MM2S;
	if(intr_times == PERIOD)
	{
		//XAudioFormatterDMAStop(&adma);
		is_done= 1;
		intr_times = 0;
		music_len -= PERIOD*PERIOD_BYTES;
		if(music_len<=PERIOD*PERIOD_BYTES)
		{
			printf("end\n");
			XAudioFormatterDMAStop(&adma);
		}
	}else if(intr_times == PERIOD/2)
	{
		//set the next part addr
//		if(debug_b)
//		{
//			music_buf_addr = music_buf_addr_debug_2;
//			debug_b = 0;
//		}
//		else
//		{
//			music_buf_addr = music_buf_addr_debug;
//			debug_b = 1;
//		}

		music_buf_addr += PERIOD*PERIOD_BYTES;
		u32 offset = XAUD_FORMATTER_MM2S_OFFSET;
		XAudioFormatter_WriteReg(adma.BaseAddress,
			XAUD_FORMATTER_BUFF_ADDR_LSB + offset,
			(u32) music_buf_addr);
		XAudioFormatter_WriteReg(adma.BaseAddress,
			XAUD_FORMATTER_BUFF_ADDR_MSB + offset,
			(u32) (music_buf_addr >> 32));
	}
	return;
}

void init_system()
{
	int status;
	XAudioFormatter_Config* adma_config;
	XScuGic_Config* intr_config;
	XI2stx_Config* tx_config;
	XIicPs_Config* iic_config;

	//init adma
	adma_config = XAudioFormatter_LookupConfig(ADMA_DEV_ID);
	status = XAudioFormatter_CfgInitialize(&adma,adma_config);
	if (status != XST_SUCCESS) {
		printf("Initialization dma failed %d\r\n", status);
	}
	adma.ChannelId = XAudioFormatter_MM2S;
	XAudioFormatter_SetMM2SCallback(&adma,
				XAudioFormatter_IOC_Handler, tx_intr_handler,
				(void *)&adma);
	XAudioFormatter_InterruptEnable(&adma,XAUD_CTRL_IOC_IRQ_MASK);
	XAudioFormatterSetFsMultiplier(&adma,MCLK,FS);
	XAudioFormatterSetHwParams(&adma,&hw_params);

	//init dma interrupt
	intr_config = XScuGic_LookupConfig(INTC_DEV_ID);
	status = XScuGic_CfgInitialize(&intc,intr_config,intr_config->CpuBaseAddress);
	if (status != XST_SUCCESS) {
		printf("Initialization dma intc failed %d\r\n", status);
	}
	XScuGic_SetPriorityTriggerType(&intc,TX_INTR_ID,0xA0, 0x3);
	status = XScuGic_Connect(&intc,TX_INTR_ID,(Xil_InterruptHandler)XAudioFormatterMM2SIntrHandler,&adma);
	if (status != XST_SUCCESS) {
		printf("Initialization intc connect failed %d\r\n", status);
	}
	XScuGic_Enable(&intc, TX_INTR_ID);

	Xil_ExceptionInit();
	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
			(Xil_ExceptionHandler)XScuGic_InterruptHandler,(void*)&intc);
	Xil_ExceptionEnable();

	//init i2s tx
	tx_config = XI2s_Tx_LookupConfig(I2S_TX_DEV_ID);
	status = XI2s_Tx_CfgInitialize(&i2s_tx,tx_config,tx_config->BaseAddress);
	if (status != XST_SUCCESS) {
		printf("Initialization i2s tx failed %d\r\n", status);
	}
	XI2s_Tx_SetSclkOutDiv(&i2s_tx,MCLK,FS);
	//XI2s_Tx_JustifyEnable(&i2s_tx,TRUE);
	//XI2s_Tx_WriteReg(i2s_tx.Config.BaseAddress,0x08, 0x06);
	//XI2s_Tx_WriteReg(i2s_tx.Config.BaseAddress,0x0c,0x01);
	XI2s_Tx_Enable(&i2s_tx,TRUE);


	//init iic
	iic_config = XIicPs_LookupConfig(IIC_DEV_ID);
	status = XIicPs_CfgInitialize(&iic,iic_config,iic_config->BaseAddress);
	if (status != XST_SUCCESS) {
		printf("Initialization iic failed %d\r\n", status);
	}
	XIicPs_SetSClk(&iic,IIC_SCLK_RATE);

}

void write_reg(u8 reg_addr, u8 reg_data)
{
	u8 data[3];
	data[0] = 0x40;
	data[1] = reg_addr;
	data[2] = reg_data;

	XIicPs_MasterSendPolled(&iic,data,3,IIC_AUDIO_ADDR);
	while(XIicPs_BusIsBusy(&iic));
}

void init_audio()
{
	//write_reg(R0_CLOCK_CONTROL, 0x01);

	unsigned char u8TxData[8], u8RxData[6];
	write_reg(R0_CLOCK_CONTROL,0x0E);

	// Write 6 bytes to R1
	u8TxData[0] = 0x40;
	u8TxData[1] = 0x02;
	u8TxData[2] = 0x00; // byte 1
	u8TxData[3] = 0x7d; // byte 2
	u8TxData[4] = 0x00; // byte 3
	u8TxData[5] = 0x0c; // byte 4
	u8TxData[6] = 0x21; // byte 5
	u8TxData[7] = 0x01; // byte 6

	XIicPs_MasterSendPolled(&iic,u8TxData,8,IIC_AUDIO_ADDR);
	while(XIicPs_BusIsBusy(&iic));
	u8TxData[0] = 0x40;
	u8TxData[1] = 0x02;

	do{
		XIicPs_MasterSendPolled(&iic, u8TxData, 2, IIC_AUDIO_ADDR);
		while(XIicPs_BusIsBusy(&iic));
		XIicPs_MasterRecvPolled(&iic, u8RxData, 6, IIC_AUDIO_ADDR);
		while(XIicPs_BusIsBusy(&iic));
	}
	while((u8RxData[5] & 0x02) == 0);

	write_reg(R0_CLOCK_CONTROL,0x0F);
	////////////////////////////////////////

//	write_reg(R4_RECORD_MIXER_LEFT_CONTROL_0,0x5B);
//	write_reg(R5_RECORD_MIXER_LEFT_CONTROL_1,0x08);
//	write_reg(R6_RECORD_MIXER_RIGHT_CONTROL_0,0x5B);
//	write_reg(R7_RECORD_MIXER_RIGHT_CONTROL_1,0x08);
//	write_reg(R8_LEFT_DIFFERENTIAL_INPUT_VOLUME_CONTROL,0x83);
//	write_reg(R9_RIGHT_DIFFERENTIAL_INPUT_VOLUME_CONTROL, 0x83);
//	write_reg(R10_RECORD_MICROPHONE_BIAS_CONTROL, 0x01);

	//write_reg(R16_SERIAL_PORT_CONTROL_1,0x40);
	//write_reg(0xEB,0x07); //R57 sampling rate setting  set DAC sample rate

	//set up dsp
	//write_reg(0xEB,0x01); //set DSP sample rate

//	write_reg(0x36,0x01); //R67 set Dejitter window size 1 core clock cycle
//	write_reg(0x28,0x04); //R34 set slew rate 85ms
//	write_reg(0x17,0x10); //R17 set DAC oversampling ratio 64x
	write_reg(R16_SERIAL_PORT_CONTROL_1,0x02); //set 0 sclk delay in LR Frame
	write_reg(R15_SERIAL_PORT_CONTROL_0,0x08);


	write_reg(R19_ADC_CONTROL, 0x13);
	write_reg(R36_DAC_CONTROL_0,0x03); //enable DAC     just 3
	write_reg(R35_PLAYBACK_POWER_MANAGEMENT,0x03); //set power manage
	write_reg(R58_SERIAL_INPUT_ROUTE_CONTROL, 0x01); //connect the i2s input to DAC
	write_reg(R59_SERIAL_OUTPUT_ROUTE_CONTROL, 0x01);
	write_reg(R65_CLOCK_ENABLE_0,0x7F); //enable the clock to serial
	write_reg(R66_CLOCK_ENABLE_1,0x01); //enable clock generate 0 for sample rate

	write_reg(R22_PLAYBACK_MIXER_LEFT_CONTROL_0, 0x21);
	write_reg(R24_PLAYBACK_MIXER_RIGHT_CONTROL_0, 0x41);
	write_reg(R26_PLAYBACK_LR_MIXER_LEFT_LINE_OUTPUT_CONTROL, 0x03);//0 dB
	write_reg(R27_PLAYBACK_LR_MIXER_RIGHT_LINE_OUTPUT_CONTROL, 0x09);//0 dB
	write_reg(R29_PLAYBACK_HEADPHONE_LEFT_VOLUME_CONTROL, 0xE7);//0 dB
	write_reg(R30_PLAYBACK_HEADPHONE_RIGHT_VOLUME_CONTROL, 0xE7);//0 dB
	write_reg(R31_PLAYBACK_LINE_OUTPUT_LEFT_VOLUME_CONTROL, 0xE6);//0 dB
	write_reg(R32_PLAYBACK_LINE_OUTPUT_RIGHT_VOLUME_CONTROL, 0xE6);//0 dB
}
